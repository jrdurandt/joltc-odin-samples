#!/usr/bin/env python3

import re
import sys
from pathlib import Path

# odin-c-bindgen doesn't rename enum (atleast version 1.0 doesn't)
# This script removed the prefix values of enums to make them more compact
# Code generated by Claude Sonnet 4


def extract_enum_prefix(enum_name, value_name):
    # Convert enum name to expected prefix pattern
    # e.g., BodyType -> JPH_BodyType_
    expected_prefix = f"JPH_{enum_name}_"

    if value_name.startswith(expected_prefix):
        return expected_prefix

    # Handle special cases where enum name might be different
    # Try to find common JPH_ pattern
    jph_match = re.match(r"(JPH_\w+_)", value_name)
    if jph_match:
        return jph_match.group(1)

    return None


def clean_enum_value(enum_name, value_name):
    # Skip values that start with underscore
    if value_name.startswith("_"):
        return None

    prefix = extract_enum_prefix(enum_name, value_name)
    if prefix and value_name.startswith(prefix):
        cleaned = value_name[len(prefix) :]
        return cleaned

    return value_name


def process_odin_file(input_file, output_file=None):
    if output_file is None:
        output_file = input_file

    with open(input_file, "r", encoding="utf-8") as f:
        content = f.read()

    lines = content.split("\n")
    processed_lines = []

    i = 0
    while i < len(lines):
        line = lines[i]

        # Check if this line starts an enum definition
        # Look for pattern: EnumName :: enum c.int {
        enum_match = re.match(r"^(\w+)\s+::\s+enum\s+", line.strip())
        if enum_match:
            enum_name = enum_match.group(1)
            processed_lines.append(line)
            i += 1

            # Process enum values until we reach the closing brace
            brace_count = line.count("{") - line.count("}")

            while i < len(lines) and brace_count > 0:
                current_line = lines[i]
                brace_count += current_line.count("{") - current_line.count("}")

                # Check if this line contains an enum value
                # Look for patterns like: \tJPH_Something_Value = 0,
                value_match = re.match(
                    r"^(\s*)([_]?JPH_\w+)(\s*=.*)?(\s*,)?(.*)$", current_line.strip()
                )
                if value_match:
                    indent_from_line = re.match(r"^(\s*)", current_line)
                    indent = indent_from_line.group(1) if indent_from_line else "\t"

                    value_name = value_match.group(2)
                    assignment = value_match.group(3) if value_match.group(3) else ""
                    comma = value_match.group(4) if value_match.group(4) else ""
                    comment = value_match.group(5) if value_match.group(5) else ""

                    # Skip values that start with underscore
                    if value_name.startswith("_"):
                        print(f"Removing {value_name} from {enum_name}")
                        i += 1
                        continue

                    # Clean the value name
                    cleaned_name = clean_enum_value(enum_name, value_name)
                    if cleaned_name and cleaned_name != value_name:
                        # Reconstruct the line with cleaned name
                        new_line = f"{indent}{cleaned_name}{assignment}{comma}{comment}"
                        processed_lines.append(new_line)
                        print(f"Cleaned {value_name} -> {cleaned_name} in {enum_name}")
                    else:
                        processed_lines.append(current_line)
                else:
                    processed_lines.append(current_line)

                i += 1
        else:
            processed_lines.append(line)
            i += 1

    # Write the processed content back to file
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(processed_lines))

    print(f"Processed enums in {input_file}")
    if output_file != input_file:
        print(f"Output written to {output_file}")


def main():
    if len(sys.argv) < 2:
        print("Usage: python clean_enums.py <input_file> [output_file]")
        print("Example: python clean_enums.py jolt.odin")
        print("Example: python clean_enums.py jolt.odin jolt_cleaned.odin")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    if not input_file.exists():
        print(f"Error: Input file '{input_file}' does not exist")
        sys.exit(1)

    output_file = Path(sys.argv[2]) if len(sys.argv) > 2 else input_file

    try:
        process_odin_file(input_file, output_file)
        print("✅ Enum cleaning completed successfully!")
    except Exception as e:
        print(f"❌ Error processing file: {e}")
        sys.exit(1)


main()
